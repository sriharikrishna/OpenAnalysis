// /!\ ATTENTION:
//
//     THIS IS AN AUTOMATICALLY GENERATED FILE
//     CREATED BY GenOutputTool.
//     DO NOT EDIT THIS FILE DIRECTLY AS IT WILL
//     BE OVERWRITTEN.
//
//     7/4/06, MMS, had to add code for mProcToFormalSetMap and
//     mCallToActualSetMap because the GenOutputTool parser choked on those.

#include "ParamBindings.hpp"

namespace OA {

  namespace DataFlow { 

    void ParamBindings::output(IRHandlesIRInterface& ir)
    {
        sOutBuild->objStart("ParamBindings");

        sOutBuild->mapStart("mCallerToCalleeMap", "CallHandle", "std::map<ProcHandle, std::map<MemRefHandle, SymHandle> > ");
        std::map<CallHandle, std::map<ProcHandle, std::map<MemRefHandle, SymHandle> > >::iterator reg_mCallerToCalleeMap_iterator;
        for(reg_mCallerToCalleeMap_iterator = mCallerToCalleeMap.begin();
            reg_mCallerToCalleeMap_iterator != mCallerToCalleeMap.end();
            reg_mCallerToCalleeMap_iterator++)
        {
            const CallHandle &first = reg_mCallerToCalleeMap_iterator->first;
            std::map<ProcHandle, std::map<MemRefHandle, SymHandle> >  &second = reg_mCallerToCalleeMap_iterator->second;
            sOutBuild->mapEntryStart();
            sOutBuild->mapKeyStart();
            sOutBuild->outputIRHandle(first, ir);
            sOutBuild->mapKeyEnd();
            sOutBuild->mapValueStart();
            sOutBuild->mapStart("second", "ProcHandle", "std::map<MemRefHandle, SymHandle> ");
            std::map<ProcHandle, std::map<MemRefHandle, SymHandle> >::iterator reg_second_iterator;
            for(reg_second_iterator = second.begin();
                reg_second_iterator != second.end();
                reg_second_iterator++)
            {
                const ProcHandle &first = reg_second_iterator->first;
                std::map<MemRefHandle, SymHandle>  &second = reg_second_iterator->second;
                sOutBuild->mapEntryStart();
                sOutBuild->mapKeyStart();
                sOutBuild->outputIRHandle(first, ir);
                sOutBuild->mapKeyEnd();
                sOutBuild->mapValueStart();
                sOutBuild->mapStart("second", "MemRefHandle", "SymHandle");
                std::map<MemRefHandle, SymHandle>::iterator reg_second_iterator;
                for(reg_second_iterator = second.begin();
                    reg_second_iterator != second.end();
                    reg_second_iterator++)
                {
                    const MemRefHandle &first = reg_second_iterator->first;
                    SymHandle &second = reg_second_iterator->second;
                    sOutBuild->mapEntryStart();
                    sOutBuild->mapKeyStart();
                    sOutBuild->outputIRHandle(first, ir);
                    sOutBuild->mapKeyEnd();
                    sOutBuild->mapValueStart();
                    sOutBuild->outputIRHandle(second, ir);
                    sOutBuild->mapValueEnd();
                    sOutBuild->mapEntryEnd();
                }
                sOutBuild->mapEnd("second");

                sOutBuild->mapValueEnd();
                sOutBuild->mapEntryEnd();
            }
            sOutBuild->mapEnd("second");

            sOutBuild->mapValueEnd();
            sOutBuild->mapEntryEnd();
        }
        sOutBuild->mapEnd("mCallerToCalleeMap");

        sOutBuild->mapStart("mCalleeToCallerMap", "CallHandle", "std::map<SymHandle, MemRefHandle> ");
        std::map<CallHandle, std::map<SymHandle, MemRefHandle> >::iterator reg_mCalleeToCallerMap_iterator;
        for(reg_mCalleeToCallerMap_iterator = mCalleeToCallerMap.begin();
            reg_mCalleeToCallerMap_iterator != mCalleeToCallerMap.end();
            reg_mCalleeToCallerMap_iterator++)
        {
            const CallHandle &first = reg_mCalleeToCallerMap_iterator->first;
            std::map<SymHandle, MemRefHandle>  &second = reg_mCalleeToCallerMap_iterator->second;
            sOutBuild->mapEntryStart();
            sOutBuild->mapKeyStart();
            sOutBuild->outputIRHandle(first, ir);
            sOutBuild->mapKeyEnd();
            sOutBuild->mapValueStart();
            sOutBuild->mapStart("second", "SymHandle", "MemRefHandle");
            std::map<SymHandle, MemRefHandle>::iterator reg_second_iterator;
            for(reg_second_iterator = second.begin();
                reg_second_iterator != second.end();
                reg_second_iterator++)
            {
                const SymHandle &first = reg_second_iterator->first;
                MemRefHandle &second = reg_second_iterator->second;
                sOutBuild->mapEntryStart();
                sOutBuild->mapKeyStart();
                sOutBuild->outputIRHandle(first, ir);
                sOutBuild->mapKeyEnd();
                sOutBuild->mapValueStart();
                sOutBuild->outputIRHandle(second, ir);
                sOutBuild->mapValueEnd();
                sOutBuild->mapEntryEnd();
            }
            sOutBuild->mapEnd("second");

            sOutBuild->mapValueEnd();
            sOutBuild->mapEntryEnd();
        }
        sOutBuild->mapEnd("mCalleeToCallerMap");

        sOutBuild->mapStart("mProcToFormalSetMap", "ProcHandle", "OA_ptr<std::set<SymHandle> >");
        std::map<ProcHandle, OA_ptr<std::set<SymHandle> > >::iterator reg_mProcToFormalSetMap_iterator;
        for(reg_mProcToFormalSetMap_iterator = mProcToFormalSetMap.begin();
            reg_mProcToFormalSetMap_iterator != mProcToFormalSetMap.end();
            reg_mProcToFormalSetMap_iterator++)
        {
            const ProcHandle &first = reg_mProcToFormalSetMap_iterator->first;
            OA_ptr<std::set<SymHandle> >  &second = reg_mProcToFormalSetMap_iterator->second;
            sOutBuild->mapEntryStart();
            sOutBuild->mapKeyStart();
            sOutBuild->outputIRHandle(first, ir);
            sOutBuild->mapKeyEnd();
            sOutBuild->mapValueStart();
            sOutBuild->listStart();
            std::set<SymHandle>::iterator setIter;
            for (setIter=second->begin(); setIter!=second->end(); setIter++) {
                SymHandle sym = *setIter;
                sOutBuild->listItemStart();
                sOutBuild->outputIRHandle(sym,ir);
                sOutBuild->listItemEnd();
            }
            sOutBuild->listEnd();
            sOutBuild->mapValueEnd();
            sOutBuild->mapEntryEnd();
        }
        sOutBuild->mapEnd("mProcToFormalSetMap");

        sOutBuild->mapStart("mCallToActualSetMap", "CallHandle", "OA_ptr<std::set<MemRefHandle> >");
        std::map<CallHandle, OA_ptr<std::set<MemRefHandle> > >::iterator reg_mCallToActualSetMap_iterator;
        for(reg_mCallToActualSetMap_iterator = mCallToActualSetMap.begin();
            reg_mCallToActualSetMap_iterator != mCallToActualSetMap.end();
            reg_mCallToActualSetMap_iterator++)
        {
            const CallHandle &first = reg_mCallToActualSetMap_iterator->first;
            OA_ptr<std::set<MemRefHandle> >  &second = reg_mCallToActualSetMap_iterator->second;
            sOutBuild->mapEntryStart();
            sOutBuild->mapKeyStart();
            sOutBuild->outputIRHandle(first, ir);
            sOutBuild->mapKeyEnd();
            sOutBuild->mapValueStart();
            sOutBuild->listStart();
            std::set<MemRefHandle>::iterator setIter;
            for (setIter=second->begin(); setIter!=second->end(); setIter++) {
                MemRefHandle ref = *setIter;
                sOutBuild->listItemStart();
                sOutBuild->outputIRHandle(ref,ir);
                sOutBuild->listItemEnd();
            }
            sOutBuild->listEnd();
            sOutBuild->mapValueEnd();
            sOutBuild->mapEntryEnd();
        }
        sOutBuild->mapEnd("mCallToActualSetMap");


    
        {
          sOutBuild->mapStart("mCallToExprListMap","CallHandle",
                              "OA_ptr<std::list<ExprHandle>");
          std::map<CallHandle, OA_ptr<std::list<ExprHandle> > >::iterator mapIter;
          OA_ptr<ExprHandleIterator> exprIter;
          for (mapIter = mCallToExprListMap.begin();
               mapIter != mCallToExprListMap.end();
               mapIter++) {
            const CallHandle &call = mapIter->first;
            exprIter = getActualExprHandleIterator(call);
            
            sOutBuild->mapEntryStart();
            sOutBuild->mapKeyStart();
            sOutBuild->outputIRHandle(call, ir);
            sOutBuild->mapKeyEnd();
            sOutBuild->mapValueStart();
            sOutBuild->listStart();
            if (!exprIter.ptrEqual(0)) {
              if (exprIter->isValid()) {
                for (; exprIter->isValid(); ++(*exprIter) ) {
                  ExprHandle expr = exprIter->current();
                  sOutBuild->listItemStart();
                  sOutBuild->outputIRHandle(expr,ir);
                  sOutBuild->listItemEnd();
                }
              } else {
                sOutBuild->listItemStart();
                sOutBuild->outputString( " expr List is Empty " );
                sOutBuild->listItemEnd();
              }
            } else {
              sOutBuild->listItemStart();
              sOutBuild->outputString( " expr List is NULL " );
              sOutBuild->listItemEnd();
            }
            
            sOutBuild->listEnd();
            sOutBuild->mapValueEnd();
            sOutBuild->mapEntryEnd();
          }
          sOutBuild->mapEnd("mCallToExprListMap");
        }

        {
          sOutBuild->mapStart("mExprToTreeMap","ExprHandle","OA_ptr<ExprTree>");
          std::map<ExprHandle,OA_ptr<ExprTree> >::iterator mapIter;
          OA_ptr<ExprTree> eTree;
          for (mapIter = mExprToTreeMap.begin();
               mapIter != mExprToTreeMap.end();
               mapIter++) {
            const ExprHandle &expr = mapIter->first;
            eTree = mapIter->second;

            sOutBuild->mapEntryStart();
            sOutBuild->mapKeyStart();
            if (!eTree.ptrEqual(0)) {
              sOutBuild->outputIRHandle(expr, ir);
            }
            sOutBuild->mapKeyEnd();
            sOutBuild->mapValueStart();
            eTree->output(ir);
            sOutBuild->mapValueEnd();
            sOutBuild->mapEntryEnd();
          }
          sOutBuild->mapEnd("mExprToTreeMap");
        }

        
        {
          sOutBuild->mapStart("mCallToFormalToActualMap","CallHandle","SymToExprHandleMap");
          std::map<CallHandle,std::map<SymHandle,ExprHandle> >::iterator mapIter;
          for (mapIter = mCallToFormalToActualMap.begin();
               mapIter != mCallToFormalToActualMap.end();
               mapIter++) {
            const CallHandle &call = mapIter->first;
            sOutBuild->mapEntryStart();
              sOutBuild->mapKeyStart();
                sOutBuild->outputIRHandle(call, ir);
              sOutBuild->mapKeyEnd();
            sOutBuild->mapValueStart();
            sOutBuild->mapStart("symToExprMap","SymHandle","ExprHandle");
            
            std::map<SymHandle,ExprHandle> symToExprMap = mapIter->second;
            std::map<SymHandle,ExprHandle>::iterator map2Iter;
            for (map2Iter = symToExprMap.begin();
                 map2Iter != symToExprMap.end();
                 map2Iter++) {
              const SymHandle &formal = map2Iter->first;
              const ExprHandle &expr = map2Iter->second;

              sOutBuild->mapEntryStart();
                sOutBuild->mapKeyStart();
                  sOutBuild->outputIRHandle(formal, ir);
                sOutBuild->mapKeyEnd();
                sOutBuild->mapValueStart();
                  sOutBuild->outputIRHandle(expr, ir);
                sOutBuild->mapValueEnd();
              sOutBuild->mapEntryEnd();
            }
            sOutBuild->mapEnd("symToExprMap");
            sOutBuild->mapValueEnd();
            sOutBuild->mapEntryEnd();
          }
          sOutBuild->mapEnd("mFormalToActualExprMap");
        }

        sOutBuild->objEnd("ParamBindings");
    }

        
  } // end of DataFlow namespace
} // end of OA namespace
