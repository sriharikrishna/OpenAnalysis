PROCEDURE foo

AliasIRInterface {

  ProcHandle (1, "foo") => 
  <
    Syms  = 
      [
        SymHandle (1, "x" ) =>  NamedLoc, <SymHandle (1,"x"), local = true, 
                                 fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (2,"y") =>  NamedLoc, <SymHandle (2,"y"), local = true, 
                               fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (3,"g") =>  NamedLoc, <SymHandle (3,"g"), local = false,
                               fullOverlap = [ ], partOverlap = [ ] > 

      ],

    Stmts = 
      [ StmtHandle(1, "x = y" ) => < ANY_STMT,
                                     [ MemRefHandle(1,"x") 
                                       MemRefHandle(2,"y")
                                     ]
                                   >
      ],

    MemRefs = 
      [
        MemRefHandle(1,"x") => 
          [ NamedRef, < SymHandle (1, "x"), addressOf = false, 
                                             fullAccuracy = true,
                                             memRefType = DEF> ]
        MemRefHandle(2,"y") => 
          [ NamedRef, < SymHandle (2,"y"), addressOf = false, 
                                            fullAccuracy = true,
                                            memRefType = USE> ]
      ]
  >
}

AccessLocIRInterface {

  ProcHandle (1, "foo(int y)") => 
  <
    // SymHandle for Procedure
    SymHandle(4, "foo"),

    // formal params
    FormalParams = [ SymHandle(1, "y") ],
    
    // these are accessible symbols for this procedure and their 
    // mapping to locations
    AccessibleSyms  = 
      [
        SymHandle (1, "x" ) => NamedLoc, <SymHandle (1,"x"), local = true, 
                                 fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (2,"y") => NamedLoc, <SymHandle (2,"y"), local = true, 
                               fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (3,"g") => NamedLoc, <SymHandle (3,"g"), local = false,
                               fullOverlap = [ ], partOverlap = [ ] > 

      ],

    // this procedure doesn't have any of these, but there is a commented
    // out example of this
    UnnamedDynAllocStmts =
      [
      //StmtHandle (2, "p = malloc()") 
      //                          
      ],

    // For each symbol, what are the possible memory references
    // that it can be involved in.  Simplest approximation is just
    // to indicate number of possible dereferences allowed.
    // This example doesn't have any pointers.
    // There is a commented out example of how that would work if x
    // were a pointer pointer (int**).
    // Here the memRefType is of no consequence.
    PossMemRefExprs = 
      [
        SymHandle (1, "x" ) => 
          [ NamedRef, < SymHandle (1, "x"), addressOf = false, 
                                              fullAccuracy = true,
                                              memRefType = USE> 
            

          //Deref, < 
          //  < NamedRef, < SymHandle (1, "x"), addressOf = false, 
          //                                    fullAccuracy = true,
          //                                    memRefType = USE> >,
          //  numDeref = 1 > 
          //

          //Deref, < 
          //  < NamedRef, < SymHandle (1, "x"), addressOf = false, 
          //                                    fullAccuracy = true,
          //                                    memRefType = USE> >,
          //  numDeref = 2 > 
          //
          ]

        SymHandle (2,"y") => 
          [ NamedRef, < SymHandle (2,"y"), addressOf = false, 
                                             fullAccuracy = true,
                                             memRefType = USE>
          ]

        SymHandle (3,"g") => 
          [ NamedRef, < SymHandle (3,"g"), addressOf = false, 
                                             fullAccuracy = true,
                                             memRefType = USE>
          ]
      ]
  >
}


END PROCEDURE foo
