// two_func.oa
// Making sure the testing framework can handle more than one procedure

PROCEDURE foo

AliasIRInterface {

  ProcHandle (1, "foo(int y)") => 
  <
    Syms  = 
      [
        SymHandle (1, "x" ) =>  NamedLoc, <SymHandle (1,"x"), local = true, 
                                 fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (2,"y") =>  NamedLoc, <SymHandle (2,"y"), local = true, 
                               fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (3,"g") =>  NamedLoc, <SymHandle (3,"g"), local = false,
                               fullOverlap = [ ], partOverlap = [ ] > 

      ],

    Stmts = 
      [ StmtHandle(1, "x = y" ) => < ANY_STMT,
                                     [ MemRefHandle(1,"x") 
                                       MemRefHandle(2,"y")
                                     ]
                                   >
      ],

    MemRefs = 
      [
        MemRefHandle(1,"x") => 
          [ NamedRef, < SymHandle (1, "x"), addressOf = false, 
                                             fullAccuracy = true,
                                             memRefType = DEF> ]
        MemRefHandle(2,"y") => 
          [ NamedRef, < SymHandle (2,"y"), addressOf = false, 
                                            fullAccuracy = true,
                                            memRefType = USE> ]
      ]
  >
}

AccessLocIRInterface {

  ProcHandle (1, "foo(int y)") => 
  <
    // SymHandle for Procedure
    SymHandle(4, "foo"),

    // formal params
    FormalParams = [ SymHandle(1, "y") ],
    
    // these are accessible symbols for this procedure and their 
    // mapping to locations
    AccessibleSyms  = 
      [
        SymHandle (1, "x" ) => NamedLoc, <SymHandle (1,"x"), local = true, 
                                 fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (2,"y") => NamedLoc, <SymHandle (2,"y"), local = true, 
                               fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (3,"g") => NamedLoc, <SymHandle (3,"g"), local = false,
                               fullOverlap = [ ], partOverlap = [ ] > 

      ],

    // this procedure doesn't have any of these
    UnnamedDynAllocStmts =
      [
      ],

    PossMemRefExprs = 
      [
        SymHandle (1, "x" ) => 
          [ NamedRef, < SymHandle (1, "x"), addressOf = false, 
                                              fullAccuracy = true,
                                              memRefType = USE> 
          ]

        SymHandle (2,"y") => 
          [ NamedRef, < SymHandle (2,"y"), addressOf = false, 
                                             fullAccuracy = true,
                                             memRefType = USE>
          ]

        SymHandle (3,"g") => 
          [ NamedRef, < SymHandle (3,"g"), addressOf = false, 
                                             fullAccuracy = true,
                                             memRefType = USE>
          ]
      ]
  >
}


END PROCEDURE foo

PROCEDURE bar

AliasIRInterface {

  ProcHandle (2, "bar") => 
  <
    Syms  = 
      [
        SymHandle (5, "a" ) =>  NamedLoc, <SymHandle (5,"a"), local = true, 
                                 fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (6,"b") =>  NamedLoc, <SymHandle (6,"b"), local = true, 
                               fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (7,"g2") =>  NamedLoc, <SymHandle (7,"g2"), local = false,
                               fullOverlap = [ ], partOverlap = [ ] > 

      ],

    Stmts = 
      [ StmtHandle(2, "a = b + g2" ) 
            => < ANY_STMT,
                 [ MemRefHandle(3,"b") 
                   MemRefHandle(4,"g2")
                   MemRefHandle(5,"a")
                 ]
               >
        StmtHandle(3, "foo(g2)" ) 
            => < ANY_STMT,
                 [ MemRefHandle(6,"g2") 
                 ]
               >
      ],

    MemRefs = 
      [
        MemRefHandle(3,"b") => 
          [ NamedRef, < SymHandle (6, "b"), addressOf = false, 
                                            fullAccuracy = true,
                                            memRefType = USE> ]
        MemRefHandle(4,"g2") => 
          [ NamedRef, < SymHandle (7,"g2"), addressOf = false, 
                                            fullAccuracy = true,
                                            memRefType = USE> ]
        MemRefHandle(5,"a") => 
          [ NamedRef, < SymHandle (5,"a"), addressOf = false, 
                                           fullAccuracy = true,
                                           memRefType = DEF> ]
        // FIXME?: this is somewhat awkward, seems like addressOf should 
        // be true and it may or may not be DEFed or USEed within procedure
        MemRefHandle(6,"g2") => 
          [ NamedRef, < SymHandle (7,"g2"), addressOf = false, 
                                            fullAccuracy = true,
                                            memRefType = USE> ]
      ]
  >
}

AccessLocIRInterface {

  ProcHandle (2, "bar") => 
  <
    // SymHandle for Procedure
    SymHandle(8, "bar"),

    // formal params
    FormalParams = [ ],
    
    // these are accessible symbols for this procedure and their 
    // mapping to locations
    AccessibleSyms  = 
      [
        SymHandle (5, "a" ) => NamedLoc, <SymHandle (5,"a"), local = true, 
                                 fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (6,"b") => NamedLoc, <SymHandle (6,"b"), local = true, 
                               fullOverlap = [ ], partOverlap = [ ] > 

        SymHandle (7,"g2") => NamedLoc, <SymHandle (7,"g2"), local = false,
                               fullOverlap = [ ], partOverlap = [ ] > 

      ],

    UnnamedDynAllocStmts =
      [
      ],

    PossMemRefExprs = 
      [
        SymHandle (5, "a" ) => 
          [ NamedRef, < SymHandle (5, "a"), addressOf = false, 
                                              fullAccuracy = true,
                                             memRefType = USE>
          ]

        SymHandle (6,"b") => 
          [ NamedRef, < SymHandle (6,"b"), addressOf = false, 
                                             fullAccuracy = true,
                                             memRefType = USE>
          ]

        SymHandle (7,"g2") => 
          [ NamedRef, < SymHandle (7,"g2"), addressOf = false, 
                                            fullAccuracy = true,
                                             memRefType = USE>
          ]
      ]
  >
}


END PROCEDURE bar
