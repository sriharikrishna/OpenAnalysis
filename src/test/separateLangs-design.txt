// one-line comments
    
PROCEDURE foo

// for now must list all visible symbols for this procedure
LocationIRShortCircuit {
  ProcHandle (1, "foo") => [
    SymHandle (1, "x" ) => < NamedLoc, <SymHandle (1,"x"), local = true, 
                                        fullOverlap = [ ], partOverlap = [ ] > >

    SymHandle (2,"y") => < NamedLoc, <SymHandle (2,"y"), local = true, 
                                      fullOverlap = [ ], partOverlap = [ ] > >

    SymHandle (3,"g") => < NamedLoc, <SymHandle (3,"g"), local = false,
                                      fullOverlap = [ ], partOverlap = [ ] > >

    StmtHandle (1, "malloc()") => < UnnamedLoc, <StmtHandle (1, "malloc()"), 
                                                 local = true > >
  ]
}

MemRefExprIRDirect {
  MemRefHandle(1,"x") => [< NamedRef, < type = def, false, true, SymHandle (1,"x")> >]
  MemRefHandle(2,"y") => [< NamedRef, < SymHandle (2,"y"), type = use, 
                                        addressOf = false, 
                                        fullAccuracy = true > >]
}

AliasIRInterface {

  ProcHandle (1, "foo") => 
  <
    Syms  => 
      [
        SymHandle (1, "x" ) => < NamedLoc, <SymHandle (1,"x"), local = true, 
                                 fullOverlap = [ ], partOverlap = [ ] > >

        SymHandle (2,"y") => < NamedLoc, <SymHandle (2,"y"), local = true, 
                               fullOverlap = [ ], partOverlap = [ ] > >

        SymHandle (3,"g") => < NamedLoc, <SymHandle (3,"g"), local = false,
                               fullOverlap = [ ], partOverlap = [ ] > >

      ],

    Stmts => 
      [ StmtHandle(1, "x = y" ) => < ANY_STMT,
                                     [ MemRefHandle(1,"x") 
                                       MemRefHandle(2,"y")
                                     ]
                                   >
      ],

    MemRefs => 
      [
        MemRefHandle(1,"x") => 
          [< NamedRef, < SymHandle (1, "x"), addressOf = false, 
                                             fullAccuracy = true,
                                             memRefType = def> >]
        MemRefHandle(2,"y") => 
          [< NamedRef, < SymHandle (2,"y"), addressOf = false, 
                                            fullAccuracy = true,
                                            memRefType = use> >]
      ]
  >
}

        StmtHandle (1, "malloc()") => < UnnamedLoc, <StmtHandle (1, "malloc()"), 
                                        local = true > >

ReachDefsIRInterface {
  ProcHandle (1, "foo") => <
    Stmts =>
        [ StmtHandle(1, "x = y" ) => 
            < Defs => [ MemRefHandle(1,"x") ] ,
              Uses => [ MemRefHandle(2,"y") ] 
            >
        ]
    
  >
}

SideEffectIRInterface {
}

END PROCEDURE foo


DESIGN logic:
-opaque handles use parens for id and debug string
-<ObjectClass, <Handle(), field1 = , ...> >
-Handle or interface concept => [] or <>
-put commas after ordered items in tuples and IRHandle pairs
-do not put commas after things in a list [], that is a bit trickier to handle
 in bison I think
-MemRefExprIRDirect, each MemRef should be unique and MRE's do not care
what function they are in, so function information is not needed
-want information for a particular procedure all put together, so will have
to parse the outside stuff by myself, can still use the same lexer?
